{/* You can add relative imports here, */}
{/* or add them when rendering the file as: */}
{/* const Content = await compile(...).default */}
{/* Content({components}) */}

import { Spacer, Title, Container, Highlight } from "./components/shared";

<Container>
  <Title>Hello! ðŸ‘‹</Title>
</Container>

---

<Container>
  <Title>Sreetam Das</Title>
  
- Senior Frontend Engineer at Remote

</Container>

---

<Container>
  <Title>Fundamentals of TypeScript</Title>
</Container>

---

## What is TypeScript?

<ul>
  <Steps>
    <li>All JavaScript is valid!</li>
    <li>You don't need to rewrite all of your code immediately</li>
    <li>*Static* type checker</li>
    <li>
      Additional <Highlight>**types**</Highlight>
    </li>
    <li>Detect errors in code *without* running it</li>
    <li>
      Based on the <Highlight>types</Highlight> of values being operated on
    </li>
  </Steps>
</ul>

---

## Why?

- Improved code reliability and maintainability
- Improved development experience

---

## Getting started with TS

- `npm install typescript` in your project
- [ts.new](https://ts.new)

---

## Getting started with TS: `tsconfig.json`

```json
// tsc --init

{
  "compilerOptions": {
    "noImplicitAny": true, // disallow `any` type
    "outDir": "dist" // output dir for compiled JS
    // ...
  },
  "exclude": ["node_modules"],
  "include": ["src"]
}
```

---

## Static typing Æ’or variables

```ts
let message: string = "Hello, world!";
let count: number = 10;
```

---

## Static typing Æ’or variables

```ts
let message = "Hello, world!";
let count = 10;

// This would cause a type error, because we are trying to
// assign a number to a variable of type string
message = 1234;
```

- TypeScript is kind of pretty smart!
- Infer basic types from the declaration

---

## A simple JS function

```ts
function greet(name) {
  console.log(`Hello ${name}!`);
}

greet("Pesto");
// Hello Pesto!
```

---

## Same but with TypeScript

```ts
function greet(name: string) {
  console.log(`Hello ${name}!`);
}

greet("Pesto");
// Hello Pesto!
```

---

## /\* CodeSandbox \*/

---

## Basic types

- JavaScript based types

```ts
let message: string = "Hello, world!";
let count: number = 10;
let isDone: boolean = false;
let nothing: null = null;
let nothing: undefined;
```

---

## Arrays type

```ts
let numbers: number[] = [1, 2, 3, 4, 5];
let messages: string[] = ["Hello", "world", "!"];
let booleans: Array<boolean> = [true, false, true, true];
```

---

## Tuples

```ts
// A tuple type with a fixed number of elements
let pair: [string, number] = ["hello", 42];

// A tuple type with optional elements
let triple: [string, number, boolean?] = ["hello", 42];
```

---

## And you can combine them as well

```ts
let people: Array<{
  name: string;
  likes: Array<string>;
  likesWindows: boolean;
}> = [
  { name: "Sreetam", likes: ["laptop stickers"], likesWindows: false },
  { name: "Megha", likes: ["subtlety", "UX"], likesWindows: false },
];
```

---

## Optional properties

```ts {4,7}
let people: Array<{
  name: string;
  likes: Array<string>;
  likesWindows?: boolean;
}> = [
  { name: "Sreetam", likes: ["laptop stickers"], likesWindows: false },
  { name: "Megha", likes: ["subtlety", "UX"] },
];
```

---

## Usage

```ts
function peopleDescription(
  input: Array<{
    name: string;
    likes: Array<string>;
    likesWindows?: boolean;
  }>
) {
  input.forEach((person) => {
    const { name, likes, likesWindows } = person;
    let description = `${name} likes ${likes.join(", ")}`;

    console.log(description);
  });
}
```

---

## Usage

```ts {11-13,16}
function peopleDescription(
  input: Array<{
    name: string;
    likes: Array<string>;
    likesWindows?: boolean;
  }>
) {
  input.forEach((person) => {
    const { name, likes, likesWindows } = person;

    function getOpinionOnWindows(opinion?: boolean) {
      return opinion ? " and likes Windows" : "";
    }

    let description = `${name} likes ${likes.join(", ")}`;
    description += getOpinionOnWindows(likesWindows);

    console.log(description);
  });
}
```

---

## Usage

```ts {12-13}
function peopleDescription(
  input: Array<{
    name: string;
    likes: Array<string>;
    likesWindows?: boolean;
  }>
) {
  input.forEach((person) => {
    const { name, likes, likesWindows } = person;

    function getOpinionOnWindows(opinion?: boolean) {
      if (typeof opinion === "undefined")
        return " and has no opinion on Windows";

      return opinion ? " and likes Windows" : "";
    }

    let description = `${name} likes ${likes.join(", ")}`;
    description += getOpinionOnWindows(likesWindows);

    console.log(description);
  });
}
```

---

## Type alias

```ts
let people: Array<{
  name: string;
  likes: Array<string>;
  likesWindows?: boolean;
}> = [
  { name: "Sreetam", likes: ["laptop stickers"], likesWindows: false },
  { name: "Megha", likes: ["subtlety", "UX"] },
];
```

---

## Type alias

```ts {1-5,7}
type Person = {
  name: string;
  likes: Array<string>;
  likesWindows?: boolean;
};

type People = Array<Person>;

let people: People = [
  { name: "Sreetam", likes: ["laptop stickers"], likesWindows: false },
  { name: "Megha", likes: ["subtlety", "UX"] },
];
```

---

## Type alias

```ts {1,3}
function peopleDescription(input: People) {
  input.forEach((person) => {
    function getOpinionOnWindows(opinion: Person["likesWindows"]) {
      //
    }
  });
}
```

---

## Union types

- Type that can be one of several different types
- Useful when value can have multiple types
- Handle each type differently

---

```ts
function formatName(name: string | string[]) {
  if (typeof name === "string") {
    return name;
  } else {
    return name.join(" ");
  }
}

formatName("Sreetam"); // Sreetam
formatName(["Sreetam", "Swapnil"]); // Sreetam Swapnil
```

---

## Type guards

- Narrow the type of a value

```ts
function formatName(name: string | string[]) {
  if (typeof name === "string") {
    // type is narrowed to string within this block
    return name;
  } else {
    // narrowed to string[] within this block
    return name.join(" ");
  }
}
```

---

## Another example for Type guards

---

## Type assertions

- Provide info back to the compiler

---

```ts
const arr = [2, 4, 6];

type Result = {
  "place-0": number;
  "place-1": number;
  "place-2": number;
};
// Type '{}' is missing the following properties from type 'Result':
// 'place-0', 'place-1', 'place-2'
const res: Result = arr.reduce((acc, curr, i) => {
  acc[`place-${i}`] = curr;

  return acc;
}, {});
```

---

```ts {12}
const arr = [2, 4, 6];

type Result = {
  "place-0": number;
  "place-1": number;
  "place-2": number;
};
const res: Result = arr.reduce((acc, curr, i) => {
  acc[`place-${i}`] = curr;

  return acc;
}, {} as Result);
```

---

## `any`

- Donâ€™t want a particular value to cause errors
- Can be literally `any`thing

```ts
function getValue(key: string) {
  // We don't know the type of the value, so we use the `any` type
  let value: any = getValueFromObject(key);

  // We can access any property or method on the value
  let upperCaseValue = value.toUpperCase();

  return upperCaseValue;
}
```

---

```ts
interface User {
  name: string;
  age: number;
  email: string;
  additionalInfo: any;
  // We do not know what this might be
  // and we do not care ðŸ¤·
}
```

---

## Interfaces

- Similar, almost interchangeably with Type aliases
- Contracts with objects
- Ensure consistent structure
- Main difference: interfaces are extendable using `extend`

---

```ts
interface User {
  name: string;
  age: number;
  email: string;
}

function getUserInfo(user: User) {
  return `${user.name} is ${user.age} years old and can be 
  contacted at ${user.email}.`;
}
```

---

```ts
let user1 = {
  name: "John Doe",
  age: 30,
  email: "john.doe@example.com",
};

let user2 = {
  name: "Jane Doe",
  age: 25,
};
```

---

```ts
console.log(getUserInfo(user1));
// No problems

console.log(getUserInfo(user2));
// Argument of type '{ name: string; age: number; }' is not assignable
// to parameter of type 'User'.
//  Property 'email' is missing in type '{ name: string; age: number; }'
//  but required in type 'User'.(2345)
```

---

```ts
interface HyperUser extends User {
  multiFactorAuth: boolean;
}
```

---

## More "fun" types

- Types from types
- Utility types
- Generics
- Literals
- `unknown`, `never`, `void`, `readonly`

---

## Types from types: `keyof`

```ts
type UserKeys = keyof User;

// a union type containing the keys of the User interface
// UserKeys is equivalent to "name" | "age" | "email"
let userKey: UserKeys = "name";
userKey = "age";
userKey = "email";

userKey = "phone";
// Error: "phone" is not one of the keys of the User interface
// Type '"phone"' is not assignable to type 'keyof User'
```

---

## Types from types: `typeof`

```ts
let user2 = {
  name: "Cassidy",
  age: 30,
};
type User2 = typeof user2;
// {
//     name: string;
//     age: number;
// }
```

---

## For opening up a object's keys

```ts
interface UserDetails {
  [property: string]: {
    name: string;
    primary: boolean;
  };
}

let userDetails: UserDetails = {
  id: {
    name: "ID",
    primary: true,
  },
  rollNumber: {
    name: "Roll no.",
    primary: false,
  },
};
```

---

## Combining them

```ts
const pages = {
  entry: "/",
  notFound: "error404",
  sourceCode: "source-code",
} as const;

type PageKeys = keyof typeof pages;
// "entry" | "notFound" | "sourceCode"

type PageValues = typeof pages[keyof typeof pages];
// "/" | "error404" | "source-code"
```

---

## `as const`

- Most strict / _narrowest_ type infer
- When you want to stay as close as possible to the actual values

---

## Mapped types

- Another object, but as a map of it's properties

---

```ts
type UserInfo = {
  name: string;
  verified: boolean;
  username: string;
};

type UserHasInfo = {
  [Property in keyof UserInfo]: boolean;
}; // same as:
type UserHasInfo = {
  name: boolean;
  verified: boolean;
  username: boolean;
};
```

---

## Literal types

```ts
type PrivateKey = `private_key_${string}`;
```

---

## Questions?

---

## `unknown`

- Represents any value
- More restrictive than `any`
- Cannot access without first checking its type

```ts
let value: unknown = "hello";
// TS error
console.log(value.toUpperCase());
// first check the type of the value
// before accessing its properties or methods
if (typeof value === "string") {
  console.log(value.toUpperCase()); // Output: "HELLO"
}
```

---

## `never`

- Value that never occurs
- Function never returns a value

```ts
function error(message: string): never {
  throw new Error(message);
}
// This function does not return a value, so its return type is never
function infiniteLoop(): never {
  while (true) {
    // ...
  }
}
```

---

## `void`

- Absence of a value.
- Function that does not return a value

```ts
function printMessage(message: string): void {
  console.log(message);
}

// This variable cannot be assigned a value, so its type is void
let empty: void;

// TS error: you cannot assign a value to a variable of type void
empty = "hello";
```

---

## `readonly`

- Properties are read-only: cannot be reassigned

```ts
interface User {
  readonly name: string;
  readonly age: number;
}
let user: User = {
  name: "John Doe",
  age: 30,
};
// TS error: because the properties of user are read-only
user.age = 35;
```

---

## Utility types: `Readonly<Type>`

```ts
interface UpdatableUser {
  name: string;
  age: number;
}
let readonlyUser: Readonly<UpdatableUser> = {
  name: "John Doe",
  age: 30,
};
readonlyUser.age = 21; // TS error
```

---

## Utility types: `Partial<Type>`

```ts
// Create a partial version of the User interface
type PartialUser = Partial<User>;

// The type of PartialUser is the same as the type of User,
// but with all properties marked as optional
let partialUser: PartialUser = {
  name: "Tejas",
};
```

---

## Utility types: `Required<Type>`

```ts
type RequiredUser = Required<PartialUser>;

// TS error: missing the following properties from
// type 'Required<Partial<User>>': age, email
let requiredUser: RequiredUser = {
  name: "Tejas",
};
```

---

## Generics

- Types that can work with multiple types
- Utility types are generics

```ts
function identity<T>(value: T): T {
  return value;
}

// Use the identity function with the string type
let message = identity("hello"); // message has the type string

// Use the identity function with the number type
let number = identity(42); // number has the type number
```

---

## Generics

```ts {1}
function identity<Type>(value: Type): Type {
  return value;
}

// Use the identity function with the string type
let message = identity("hello"); // message has the type string

// Use the identity function with the number type
let number = identity(42); // number has the type number
```

---

## Generics

```ts
interface Pair<T, U> {
  first: T;
  second: U;
}
let pair: Pair<string, number> = {
  first: "hello",
  second: 42,
};
let anotherPair: Pair<boolean, string> = {
  first: true,
  second: "world",
};
```

---

## Generics

```ts {1-4}
interface Pair<FirstType, SecondType> {
  first: FirstType;
  second: SecondType;
}
let pair: Pair<string, number> = {
  first: "hello",
  second: 42,
};
let anotherPair: Pair<boolean, string> = {
  first: true,
  second: "world",
};
```

---

<Container>
  <Title>Fin.</Title>
</Container>

---

<Container>
  <Title>Fin?</Title>
</Container>

---

- ## tRPC
- ## Bubble sort in Types
- and a lot more

---

## Resources

- [TypeScript handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- Lots of courses and guides on YouTube
- even Twitter

---

## What I've used

- [MDX _Frisson_](https://github.com/sreetamdas/mdx-frisson)
- Iosevka font
- [sreetamdas.com/uses](https://sreetamdas.com/uses)
- @\_SreetamDas

---

<Container>
  <Title>Ask my anything!</Title>
</Container>
